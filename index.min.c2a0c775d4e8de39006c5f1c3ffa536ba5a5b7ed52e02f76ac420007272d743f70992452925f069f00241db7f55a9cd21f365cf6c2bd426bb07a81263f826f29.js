var suggestions=document.getElementById('suggestions'),search=document.getElementById('search');search!==null&&document.addEventListener('keydown',inputFocus);function inputFocus(a){a.ctrlKey&&a.key==='/'&&(a.preventDefault(),search.focus()),a.key==='Escape'&&(search.blur(),suggestions.classList.add('d-none'))}document.addEventListener('click',function(a){var b=suggestions.contains(a.target);b||suggestions.classList.add('d-none')}),document.addEventListener('keydown',suggestionFocus);function suggestionFocus(c){const d=suggestions.classList.contains('d-none');if(d)return;const a=[...suggestions.querySelectorAll('a')];if(a.length===0)return;const b=a.indexOf(document.activeElement);if(c.key==="ArrowUp"){c.preventDefault();const d=b>0?b-1:0;a[d].focus()}else if(c.key==="ArrowDown"){c.preventDefault();const d=b+1<a.length?b+1:b;a[d].focus()}}(function(){var a=new FlexSearch.Document({tokenize:"forward",cache:100,document:{id:'id',store:["href","title","description"],index:["title","description","content"]}});a.add({id:0,href:"/basics/getting-started/",title:"Getting Started ðŸš€",description:"Let's get started with fullstackhero!",content:"    Problem Statement # Ever gone through the pain of setting up new Projects from scratch each and every time? fullstackhero aims to address this pain point by offering Starting Points aka Boilerplates for various technologies that can help save over 200+ hours of Development and Research Time for Developers and Teams.\nSolution # fullstackhero offers Boilerplates with latest packages and services that your projects will ever need. We intend to provide Clean and Well structured Boilerplates with top-notch quality following standard coding practices and Clean Architecture principles that makes your development experience seamless. Most importantly, fullstackhero is completely FREE to use!\nAs the name suggests, the idea is to provide a full-stack end to end solution to kick start products of any scale following a modularized monolith architecture with well cut designs, code readability, scalability as the out-of-the-box features. Bottomline, using fullstackhero, your new projects will be up and running in no time.\nVision # fullstackhero is not a single repository or project, rather a collection of boilerplates out of which you get to choose your preference. In the long term, fullstackhero would ideally have multiple API projects that are written in various technologies like .NET, Node.js, GoLang and multiple client applications that are built on awesome tech like Blazor, Vue.js, React, Angular and so on.\nfullstackhero should be the one-stop that caters to the needs of various developers in various technology. This obviously would require a lot of community adaptation and contributions.\nAs of the initial releases, fullstackhero sports an API Project built on Microsoft\u0026rsquo;s newest .NET 6 and the front-end application (that consumes the .NET 6 Web API) built with Blazor WebAssembly!\nProjects # Here are the awesome fullstackhero projects!\n  .NET 6 Web API Boilerplate server dotnet multitenancy  Get to work with the latest and greatest of Microsoft's .NET 6 Web API fused with the goodness of fullstackhero.\nView Github Repository | Read Getting Started Guide\n  Blazor WebAssembly Boilerplate client application dotnet blazor webassembly multitenancy  Clean Architecture Boilerplate Template for .NET 6.0 Blazor WebAssembly built for FSH WebAPI with the goodness of MudBlazor Components.\nView Github Repository | Read Getting Started Guide\n  Angular Material Boilerplate Coming Soon!\n ASP.NET MVC Boilerplate Coming Soon!\n   "}).add({id:1,href:"/blazor-webassembly-boilerplate/general/overview/",title:"Overview",description:".NET WebAPI Boilerplate Template built with .NET 6.0. Incorporates the most essential Packages your projects will ever need. Follows Clean Architecture Principles.",content:"Blazor WebAssembly Boilerplate # Built with .NET 6.0 and the goodness of MudBlazor Component Library. Incorporates the most essential Packages your projects will ever need. Follows Clean Architecture Principles.\nGoals # The goal of this repository is to help developers / companies kickstart their Web Application Development with a pre-built Blazor WebAssembly Boilerplate that includes several much needed components and features.\n Note that this is a frontend / client application only! The backend for this application is available in a seperate repository.\n Find fullstackhero\u0026rsquo;s .NET 6 Web API Boilerplate here - https://github.com/fullstackhero/dotnet-webapi-boilerplate   Prerequisites #  Make sure you have the API Running. Here is FSH Backend - https://github.com/fullstackhero/dotnet-webapi-boilerplate Once fullstackhero\u0026rsquo;s .NET 6 Web API is up and running, run the Blazor WebAssembly Project to consume it\u0026rsquo;s services.  Community #  Discord @fullstackhero Facebook Page @codewithmukesh Youtube Channel @codewithmukesh  Contributors # Submit your PR and join the elite list!\n License # This project is licensed with the MIT license.\nSupport â­ # Has this Project helped you learn something New? or Helped you at work? Here are a few ways by which you can support.\n Leave a star! â­ Recommend this awesome project to your colleagues. ðŸ¥‡ Do consider endorsing me on LinkedIn for ASP.NET Core - Connect via LinkedIn ðŸ¦¸ Or, If you want to support this project in the long run, consider buying me a coffee! â˜•  "}).add({id:2,href:"/dotnet-webapi-boilerplate/general/overview/",title:"Overview",description:".NET WebAPI Boilerplate Template built with .NET 6.0. Incorporates the most essential Packages your projects will ever need. Follows Clean Architecture Principles.",content:"What\u0026rsquo;s fullstackhero\u0026rsquo;s .NET Web API Boilerplate? # fullstackhero\u0026rsquo;s .NET Web API Boilerplate is a starting point for your next .NET 6 Clean Architecture Project that incorporates the most essential packages and features your projects will ever need including out of the box Multi-Tenancy support. This project can save well over 200+ hours of development time for your team.\n As the name suggests, this is an API / Server Boilerplate. You can find other Client Boilerplates that consume this API under @fullstackhero handle.\n Find Blazor WebAssembly Boilerplate here - https://github.com/fullstackhero/blazor-wasm-boilerplate   Goals # The goal of this repository is to provide a complete and feature-rich starting point for any .NET Developer / Team to kick-start their next major project using .NET 6 Web API. This also serves the purpose of learning advanced concepts and implementations such as Multitenancy, CQRS, Onion Architecture, Clean Coding standards and so on.\nFeatures #  Built on .NET 6.0 Follows Clean Architecture Principles Domain Driven Design Completely Documented at fullstackhero.net Multi Tenancy Support with Finbuckle  Create Tenants with Multi Database / Shared Database Support Activate / Deactivate Tenants on Demand Upgrade Subscription of Tenants - Add More Validity Months to each tenant!   Supports MySQL, MSSQL, Oracle \u0026amp; PostgreSQL!   Click to See More!  Uses Entity Framework Core as DB Abstraction Flexible Repository Pattern Dapper Integration for Optimal Performance Serilog Integration with various Sinks - File, SEQ, Kibana OpenAPI - Supports Client Service Generation Mapster Integration for Quicker Mapping API Versioning Response Caching - Distributed Caching + REDIS Fluent Validations Audit Logging Advanced User \u0026amp; Role Based Permission Management Code Analysis \u0026amp; StyleCop Integration with Rulesets JSON Based Localization with Caching Hangfire Support - Secured Dashboard File Storage Service Test Projects JWT \u0026amp; Azure AD Authentication MediatR - CQRS SignalR Notifications \u0026amp; Much More   Getting Started # To get started with this Boilerplate, here are the avaiable options.\n Install using dotnet new . Use this for release versions of the Boilerplate only. Fork the Repository. Use this if you want to always keep your version of the Boilerplate up-to date with the latest changes.   Make sure that your DEV enviroment is setup, Read the Development Environment Guide\n Forking the Repository # You would probably need to take this approach if you want to keep your source code upto date with the latest changes. To get started based on this repository, you need to get a copy locally. You have three options: fork, clone, or download.\n Make a fork of this repository in your Github account. Create your new dotnet-webapi-boilerplate personal project by cloning the forked repository on your personal github. Setup an upstream remote on your personal project pointing to your forked repository using command git remote add upstream https://github.com/{githubuseraccount}/dotnet-webapi-boilerplate and git remote set-url --push upstream DISABLE  For step by step instructions, follow this and this.\nUsing the .NET CLI # Open up your Command Prompt / Powershell and run the following command to install the solution template.\ndotnet new --install FullStackHero.WebAPI.Boilerplate  This would install the fullstackhero .NET WebAPI Boilerplate template globally on your machine. With that done, let\u0026rsquo;s see how you can start generating complete .NET WebAPI Solutions seamlessly.\nSimply navigate to a new directory (wherever you want to place your new solution), and open up Command Prompt at the opened directory.\nRun the following command. Note that, in this demonstration, I am naming my new solution as FSH.Starter.\ndotnet new fsh-api -o FSH.Starter  For further steps and details, Read the Getting Started Guide\nImportant Links \u0026amp; Documentations # Overview - Read\nGetting Started - Read\nDevelopment Environment - Learn about setting up the DEV environment\nTrack Progress - Release 1.0 Milestones\nParticipate in Discussions - QNA \u0026amp; General Discussions\nJoin our Discord - fullstackhero @ Discord\nChangelogs # View Complete Changelogs.\nCommunity #  Discord @fullstackhero Facebook Page @codewithmukesh Youtube Channel @codewithmukesh  Contributors # Submit your PR and join the elite list!\n License # This project is licensed with the MIT license.\nSupport â­ # Has this Project helped you learn something New? or Helped you at work? Here are a few ways by which you can support.\n Leave a star! â­ Recommend this awesome project to your colleagues. ðŸ¥‡ Do consider endorsing me on LinkedIn for ASP.NET Core - Connect via LinkedIn ðŸ¦¸ Or, If you want to support this project in the long run, consider buying me a coffee! â˜•  "}).add({id:3,href:"/blazor-webassembly-boilerplate/general/development-environment/",title:"Development Environment",description:"Setting up the Development Environment for the Blazor WebAssembly Boilerplate",content:"fullstackhero\u0026rsquo;s Blazor WebAssembly Boilerplate Project Development needs you to have the following applications / tools available on your machine. Please Note that this project is being built on a Windows 10 Machine using Visual Studio Code IDE.\n.NET SDK # As mentioned earlier, this project is built with the latest available .NET SDK, which is .NET 6.0.\nEnsure that you have the latest version of the SDK available - Download from Microsoft\nðŸ’¡  Note : At the time of compiling this documentation, the latest version available was SDK 6.0.200   IDE # Visual Studio Code IDE is the recommended IDE to use for fullstackhero\u0026rsquo;s Blazor WebAssembly Boilerplate Project Development. If you are not already using this IDE, consider switching to it. It\u0026rsquo;s definitely worth it! (Fun Fact : I recently switched from Visual Studio 2019 Community to Visual Studio Code and it\u0026rsquo;s been awesome!)\nHowever, you are always free to use your choice of IDEs as well.\nIncase you intend to use Visual Studio Code for development, here are a bunch of helpful extensions that I use:\n EditorConfig for VS Code C# C# Extensions Docker Markdown All in One NuGet Gallery Material Icon Theme REST Client  ðŸ’¡  Note : All the screenshots included in these documentations are from Visual Studio Code Point of View.   "}).add({id:4,href:"/dotnet-webapi-boilerplate/general/development-environment/",title:"Development Environment",description:"Setting up the Development Environment for the .NET WebApi Boilerplate",content:"fullstackhero\u0026rsquo;s .NET WebApi Boilerplate Project Development needs you to have the following applications / tools available on your machine. Please Note that this project is being built on a Windows 10 Machine using Visual Studio Code IDE.\n.NET SDK # As mentioned earlier, this project is built with the latest available .NET SDK, which is .NET 6.0.\nEnsure that you have the latest version of the SDK available - Download from Microsoft\nðŸ’¡  Note : At the time of compiling this documentation, the latest version available was SDK 6.0.200   IDE # Visual Studio Code IDE is the recommended IDE to use for fullstackhero\u0026rsquo;s .NET WebApi Boilerplate Project Development. If you are not already using this IDE, consider switching to it. It\u0026rsquo;s definitely worth it! (Fun Fact : I recently switched from Visual Studio 2019 Community to Visual Studio Code and it\u0026rsquo;s been awesome!)\nHowever, you are always free to use your choice of IDEs as well.\nIncase you intend to use Visual Studio Code for development, here are a bunch of helpful extensions that I use:\n EditorConfig for VS Code C# C# Extensions Docker Markdown All in One NuGet Gallery Material Icon Theme REST Client  ðŸ’¡  Note : All the screenshots included in these documentations are from Visual Studio Code Point of View.   Database Servers # fullstackhero\u0026rsquo;s .NET WebApi Boilerplate gives you the freedom to choose between the following 4 popular Database Providers. Please note that with the current architecture of the API Project, it would rather be easy to add in support for more DB Providers with minimal change of code. But as of now, here are the 4 Supported Database Providers! By default, MSSQL is chosen as the Database Provider.\n Make sure that you have at least one of these servers installed, along with a Database Management tool like Azure Data Studio / PostgreSQL pgAdmin / MySQL Workbench   MSSQL # There are high chances that you already have this installed on your machine. This is ideal for development and production for small-mid server applications.\n Check out the Community versions of this Server - Get from Microsoft Download SQL Server Management Studio (SSMS) - Get from Microsoft Download Azure Data Studio to browse your MSSQL Databases - Get from Microsoft  MySQL #  Check out the Community versions of this Server - Get from mysql Download MySQL Workbench - Get from mysql  PostgreSQL # Probably the best Open Source Database Server with lots of Enterprise level features.\n Download postgresql Installer - Get from postgresql.org  Oracle #  Download  API Testing # When it comes to API Testing, Postman is the recommended tool. I have made sure to include a Postman Collection within the Repository under /postman folder to make sure you can test out all the existing endpoints. Note that there will be a detailed guide on how to use the given Postman Collection.\n Download Postman - Get from postman.com  "}).add({id:5,href:"/basics/exploring-docs/",title:"Exploring Docs",description:"Exploring fullstackhero Docs!",content:"fullstackhero sports a pretty much straight forward documentation website that is frequently updated and also accepts new documentations / corrections from the community!\n   "}).add({id:6,href:"/basics/contributing/",title:"Contributing",description:"Let's get started with fullstackhero!",content:"Being a completely community driven project, I encourage the community to submit their valuable contributions to whichever repository they are comfortable with.\nCurrently, you can contribute to -\n fullstackhero Documentation - https://github.com/fullstackhero/docs .NET Web API Boilerplate - https://github.com/fullstackhero/dotnet-webapi-boilerplate Blazor WebAssembly Boilerplate - https://github.com/fullstackhero/blazor-wasm-boilerplate  Docs # How to contribute? # Please note the following steps are applicable only for the docs repository.\n Fork the docs Repository to your Github Profile. [Optional] Navigate to your newly forked Repository -\u0026gt; Settings -\u0026gt; Secrets. [Optional] Here, Add a new Repository Secret with a name GT_TOKEN. As for the value, paste in your GitHub Token (https://github.com/settings/tokens) Now, clone this repository locally. Ensure that you have Node.js and Visual Code installed. At the root of the repository run npm install. This installs all the required packages. Might take some time depending on your network connection. All the documentations are to be written in markdown format. Refer https://github.com/fullstackhero/docs/blob/main/content/en/dotnet-webapi-boilerplate/general/getting-started/index.md to get an idea on how to write documentation and include images, code snippets and stuff. To run the application locally, run the command npm run start and navigate to localhost:1313 Once ready, send a Pull Request.  Blazor WebAssembly Boilerplate # Here are the contributors of the Blazor WASM Project! Submit your PR to join this Elite list ;) Make sure your code is warning free!\n .NET Web API Boilerplate # Submit your PR and join the elite list!\n "}).add({id:7,href:"/dotnet-webapi-boilerplate/general/getting-started/",title:"Getting Started ðŸš€",description:"Let's get started with the .NET WebApi Boilerplate!",content:"Firstly, make sure that you have already setup your development environment that runs the prerequisite tools and SDKs. Refer Development Environment for details.\nThis guide will take you right from strating up your own .NET Web API Project using fullstackhero .NET WebAPI Boilerplate package / repository to testing the API using the provided Postman Collection!\nTo get started with this Boilerplate, here are the avaiable options.\n Forking the Repository. Use this if you want to always keep your version of the Boilerplate up-to date with the latest changes. Install using dotnet new . Use this for release versions of the Boilerplate only. It might be very hard to update to the latest version of the Boilerplate using this option.  Forking the Repository \u0026amp; Creating your New Solution! # You would probably need to take this approach if you want to keep your source code upto date with the latest changes. To get started based on this repository, you need to get a copy locally.\n Make a fork of fullstackhero\u0026rsquo;s dotnet-webapi-boilerplate repository in your Github account. Next, since you need to start your private personal project, create your new dotnet-webapi-boilerplate personal project by cloning the forked repository on your personal github. This could be done as simple as running git clone https://github.com/{yourgithubuseraccount}/dotnet-webapi-boilerplate.git locally on your development machine. Setup an upstream remote on your personal project pointing to your forked repository using command git remote add upstream https://github.com/{yourgithubuseraccount}/dotnet-webapi-boilerplate and git remote set-url --push upstream DISABLE  Now, whenever there is a new update on fullstackhero\u0026rsquo;s dotnet-webapi-boilerplate repository, you could simply pull in the latest change on your private fork of the fullstackhero\u0026rsquo;s dotnet-webapi-boilerplate repository and later merge these changes with you personal projects.\nFor step by step instructions, follow this and this.\nInstalling NuGet Package # This is by far the easiest and the most streamlined way of getting the latest available Release version of fullstackhero .NET WebApi Boilerplate.\nOpen up your Command Prompt / Powershell and run the following command to install the solution template.\ndotnet new -i FullStackHero.WebAPI.Boilerplate  or, if you want to use a specific version of the boilerplate, use\ndotnet new -i FullStackHero.WebAPI.Boilerplate::0.0.6-rc     This would install the fullstackhero .NET WebAPI Boilerplate template globally on your machine. Do note that, at the time of writing this documentation, the latest available version is 0.0.6-rc which is also one of the first stable pre-release version of the package. It is highly likely that there is already a newer version available when you are reading this.\n To get the latest version of the package, visit nuget.org\nFullStackHero.WebAPI.Boilerplate is now in pre-release state. You can find the latest version on NuGet.org\n Creating your First Solution #  Note that this is not valid only if you have installed the NuGet package of this Boilerplate.\n Now that you have installed the template locally on your machine, let\u0026rsquo;s see how you can start generating complete .NET WebAPI Solutions seamlessly.\nSimply navigate to a new directory (wherever you want to place your new solution at), and open up Command Prompt at the opened directory.\nRun the following command. Note that, in this demonstration I am naming my new solution as FSH.Starter.\ndotnet new fsh-api -o FSH.Starter     Once that is done, your new solution is created for you. As simple as that!\nHere are the folders and files created for you.\n   Alternatively.. #  Note that this is valid only if you have installed the NuGet package of this Boilerplate.\n When you installed the NuGet package, there is also an entry that has been created into your Visual Studio Template for fullstackhero\u0026rsquo;s .NET WebAPI Boilerplate. If you find it easier to work with Visual Studio rather than CLI Commands to generate new solutions, you are free to do so.\nSimply open up Visual Studio 2022 and Click on Create New Project.\n   Important - Make sure to check the \u0026lsquo;Place solution and project in same directory\u0026rsquo; option. Else the solution and projects will be created on different folders and there will be build errors stating that few files are not found.\n   Another issue I noticed with creating solutions via Visual Studio is that the Solution structure might be lost. This is a very minor bug, that maybe someone can figure out and fix in our template configuration. Microsoft doesn\u0026rsquo;t seem to have very detailed guide about this.\nHowever, it\u0026rsquo;s always recommended to create new solutions via the Console.\nRunning the Application # Next, open up command prompt on this directory and run the following.\ncode .  This opens up the solution via Visual Code. Make sure that you have the prerequisite tools and SDKs setup.\nSetting up the Connection String # Next, let\u0026rsquo;s set up some valid connection strings. Navigate to src/Host/Configurations and open up database.json. Here you would have to provide a valid connection string under the DatabaseSettings to either MSSQL, MySQL or PostgreSQL instance. Below are some sample settings for each of the DB Providers.\nDetails on the usage of other Settings will be explained in the upcoming documentations.\n It is important to update the src/Host/Configurations/hangfire.json connection string / provider as well.   MySQL # \u0026quot;DatabaseSettings\u0026quot;: { \u0026quot;ConnectionString\u0026quot;: \u0026quot;server=localhost;uid=root;pwd=root;database=defaultRootDb;Allow User Variables=True\u0026quot;, \u0026quot;DBProvider\u0026quot;: \u0026quot;mysql\u0026quot; }  MSSQL # \u0026quot;DatabaseSettings\u0026quot;: { \u0026quot;DBProvider\u0026quot;: \u0026quot;mssql\u0026quot;, \u0026quot;ConnectionString\u0026quot;: \u0026quot;Data Source=(localdb)\\\\mssqllocaldb;Initial Catalog=rootTenantDb;Integrated Security=True;MultipleActiveResultSets=True\u0026quot; }  PostgreSQL # \u0026quot;DatabaseSettings\u0026quot;: { \u0026quot;ConnectionString\u0026quot;: \u0026quot;Host=localhost;Database=rootTenantDb;Username=postgres;Password=root;Include Error Detail=true\u0026quot;, \u0026quot;DBProvider\u0026quot;: \u0026quot;postgresql\u0026quot; }  Oracle # { \u0026quot;DatabaseSettings\u0026quot;: { \u0026quot;DBProvider\u0026quot;: \u0026quot;oracle\u0026quot;, \u0026quot;ConnectionString\u0026quot;: \u0026quot;Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=127.0.0.1)(PORT=49154))(CONNECT_DATA =(SERVER=DEDICATED)(SERVICE_NAME=ORCLPDB1.localdomain)));User Id=fullstack;Password=password123\u0026quot; } }  Now you need to navigate to the Host (API) Project directory via CMD or VSCode\u0026rsquo;s native terminal and run the basic build and run command to get the API up and running. Run the following.\ncd src/Host dotnet build dotnet run     As you can see from the logs, a couple of operations happen as soon as you launch the application. Let me give a brief idea on what happens when you run the application for the very first time.\n The Migrations that already come out-of-the-box with the application gets applied. Note that you do not have to manually update the database using code. Being a Multitenant solution, the Application is programmed to seed a default Tenant named root, that is basically the super-admin of the entire application and has permissions to manage tenants. Once Tenant record is seeded, the tenant admin , roles and permissions are also seeded. Note that the default credentials for the root tenant admin are as follows.  { \u0026quot;email\u0026quot;:\u0026quot;admin@root.com\u0026quot;, \u0026quot;password\u0026quot;:\u0026quot;123Pa$$word!\u0026quot; }   The Connection String that you provided in the appSettings will be taken as the root Tenant\u0026rsquo;s Connection. Note that all the tenant data will be stored on to this connection under the Tenants table.  "}).add({id:8,href:"/blazor-webassembly-boilerplate/general/getting-started/",title:"Getting Started ðŸš€",description:"Getting Started with fullstackhero's Blazor WebAssembly Boilerplate.",content:"Firstly, make sure that you have already setup your development environment that runs the prerequisite tools and SDKs. Refer Development Environment for details.\nTo get started with this Boilerplate, here are the avaiable options.\n Fork the Repository. Use this if you want to always keep your version of the Boilerplate up-to date with the latest changes. Install using dotnet new . Use this for release versions of the Boilerplate only. Note that this option is currently unavailable for Blazor WASM Boilerplate.  Forking the Repository # You would probably need to take this approach if you want to keep your source code upto date with the latest changes. To get started based on this repository, you need to get a copy locally. You have three options: fork, clone, or download.\n Make a fork of fullstackhero\u0026rsquo;s blazor-wasm-boilerplate repository in your Github account. Next, since you need to start your private personal project, create your new blazor-wasm-boilerplate personal project by cloning the forked repository on your personal github. This could be done as simple as running git clone https://github.com/{yourgithubuseraccount}/blazor-wasm-boilerplate.git locally on your development machine. Setup an upstream remote on your personal project pointing to your forked repository using command git remote add upstream https://github.com/{yourgithubuseraccount}/blazor-wasm-boilerplate and git remote set-url --push upstream DISABLE  Now, whenever there is a new update on fullstackhero\u0026rsquo;s blazor-wasm-boilerplate repository, you could simply pull in the latest change on your private fork of the fullstackhero\u0026rsquo;s blazor-wasm-boilerplate repository and later merge these changes with you personal projects.\nFor step by step instructions, follow this and this.\nInstalling NuGet Package # This is by far the easiest and the most streamlined way of getting the latest available Release version of fullstackhero Blazor WebAssembly Boilerplate.\nOpen up your Command Prompt / Powershell and run the following command to install the solution template.\ndotnet new --install FullStackHero.BlazorWebAssembly.Boilerplate  or, if you want to use a specific version of the boilerplate, use\ndotnet new --install FullStackHero.BlazorWebAssembly.Boilerplate::0.0.1-rc  This would install the fullstackhero Blazor WebAssembly Boilerplate template globally on your machine. Do note that, at the time of writing this documentation, the latest available version is 0.0.1-rc which is also one of the first stable pre-release version of the package. It is highly likely that there is already a newer version available when you are reading this.\n To get the latest version of the package, visit nuget.org\nFullStackHero.BlazorWebAssembly.Boilerplate is now in pre-release state. You can find the latest version on NuGet.org\n  FullStackHero.BlazorWebAssembly.Boilerplate::0.0.1-rc is compatible only with FullStackHero.WebAPI.Boilerplate::0.0.6-rc and above.   Get the .NET WebApi Boilerplate by running the following command\ndotnet new --install FullStackHero.WebAPI.Boilerplate::0.0.6-rc  Creating your First Solution #  Note that this is not valid only if you have installed the NuGet package of this Boilerplate.\n Now that you have installed the template locally on your machine, let\u0026rsquo;s see how you can start generating Blazor Web Assembly Projects.\nSimply navigate to a new directory (wherever you want to place your new solution at), and open up Command Prompt at the opened directory.\nRun the following command. Note that, in this demonstration I am naming my new solution as FSH.Blazor.\ndotnet new fsh-blazor -o FSH.Blazor  Once that is done, your new solution is created for you. As simple as that!\nRunning the Application # Firstly, keep in mind that this is a client application that actually consumes data by sending HTTP Requests to the API Server. Thus, you need to make sure that the API is up and running.\nTo learn about setting up the API Server, refer Getting Started with fullstackhero\u0026rsquo;s .NET Web API.\nOnce the Server is up and running, like any other Blazor application, simply navigate to the Host folder under the source folder of the Blazor Project (\\src\\Host) and run the following standard commands.\n dotnet restore dotnet build dotnet run  Once the build process is complete, the application would be reachable by accessing https://localhost:5002 on your browser.\nBy default, the API Server is set to be running on port 5001 of your local machine. If for some port related reason, you have to run the API on another port or so, navigate to src\\Client\\wwwroot\\appsettings.json of the Blazor Project and change the API Base URL Property and set the value to the port that\u0026rsquo;s exposing the API. This is the default configuration \u0026quot;ApiBaseUrl\u0026quot;: \u0026quot;https://localhost:5001/\u0026quot;.\nSimalarly, the Blazor Project by default is set to run on port 5003 of your local machine. Incase you change this to something else, ensure that you have updated the cors.json configuration file on your API project. This makes sure that there is no CORS related issues while the Blazor project tries to access the API Endpoints.\n"}).add({id:9,href:"/dotnet-webapi-boilerplate/general/api-testing/",title:"API Testing",description:"Testing fullstackhero's Web API",content:"fullstackhero\u0026rsquo;s Web API can be tested via Postman as well as the built in Swagger.\nOnce the WebAPI is up and running (by default of port 5001 of localhost), here are the ways to test the functionalilty easily.\nSwagger # Navigate to https://localhost:5001/swagger/index.html\n   Here you can see all the available endpoints. Since all of the endpoints except the login and registration endpoints are secured, you would need a Authentication Token to access these services.\nLet\u0026rsquo;s see how to generate a token via Swagger.\nYou would have to the /token endpoint for this.\n   As mentioned earlier, the default credentials are\n{ \u0026quot;email\u0026quot;:\u0026quot;admin@root.com\u0026quot;, \u0026quot;password\u0026quot;:\u0026quot;123Pa$$word!\u0026quot; }  and the default tenant is root. Once you send a POST request to the /token endpoint with these parameters, the API would return a valid JWT token which can be used to authenticate your further requests to various other endpoints of the API.\nBelow is the response sent by the API.\n   Once you have the token, simply copy it , click on the Authoize button (found at the top of the Swagger UI) and paste the token as shown below. This makes sure that the token is sent alongwith all the requests as an Auth Header.\n   Postman # Now that our application is up and running, let\u0026rsquo;s fire up POSTMAN and run some basic requests. You can find the updated Postman collection under the /postman folder of your solution or here. Import this postman collection on to your local Postman.\nNote that I have set up some default collection variables to make things easier.\n   In case your application happens to start on a different Port, you would have to change the url variable on this collection and save it.\nGenerating Access Token # Let\u0026rsquo;s start by generating a token for the root admin user! Navigate to the Identity/get-token request and simply run it. If everything goes as expected, you would be seeing a valid token as your response.\nNote that here, we are passing the tenant header as root\n   Whenever a valid token is generated via Postman, it is stored as a variable of the collection and is used by default for all the subsequent requests via Postman until the token expires. By default, tokens have a lifetime of 60 minutes which is configurable via the Host/Configurations/security.json under SecuritySettings / JwtSettings / tokenExpirationInMinutes.\nSearch Brands # You can test that the token is valid by sending the \u0026lsquo;search-brands\u0026rsquo; request.\nYour request body would look somewhat like this:\n{ \u0026quot;keyword\u0026quot;: \u0026quot;\u0026quot;, \u0026quot;pageNumber\u0026quot;: 0, \u0026quot;pageSize\u0026quot;: 10, \u0026quot;orderBy\u0026quot;: [ \u0026quot;id\u0026quot; ] }  So, by default as soon as your application in run for the first time, a couple of Brands are seeded into the database for demo purposes.\nThe keyword parameter in the above request denotes the keyword you want to search for in the brands table. Let\u0026rsquo;s leave it empty for now and let all the other parameters stay unchanged.\nPresuming that you have a valid token you\u0026rsquo;ll see:\n   { \u0026quot;data\u0026quot;: [ { \u0026quot;id\u0026quot;: \u0026quot;ca6247e8-3d7a-4c04-8d64-08d9f76d2c72\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Razor\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Sample Data\u0026quot; }, { \u0026quot;id\u0026quot;: \u0026quot;c5b447c6-a518-4268-8d65-08d9f76d2c72\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Samsung\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Sample Data\u0026quot; }, { \u0026quot;id\u0026quot;: \u0026quot;bb49e53d-9149-41d3-8d66-08d9f76d2c72\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;MSI\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Sample Data\u0026quot; }, { \u0026quot;id\u0026quot;: \u0026quot;3214bf2d-9a0d-454e-8d67-08d9f76d2c72\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Huawei\u0026quot;, \u0026quot;description\u0026quot;: \u0026quot;Sample Data\u0026quot; } ], \u0026quot;currentPage\u0026quot;: 1, \u0026quot;totalPages\u0026quot;: 1, \u0026quot;totalCount\u0026quot;: 4, \u0026quot;pageSize\u0026quot;: 10, \u0026quot;hasPreviousPage\u0026quot;: false, \u0026quot;hasNextPage\u0026quot;: false }  Create a new Brand # Let\u0026rsquo;s create a new Brand. Open up Catalog/Brands/create-brand request via Postman and POST the following body.\n{ \u0026quot;name\u0026quot;:\u0026quot;Bra1nod #29\u0026quot;, \u0026quot;description\u0026quot;:\u0026quot;Something Cool!\u0026quot; }  Once you send your request and things work as expected, the API would send back a 200 Status Code along with your new Brand\u0026rsquo;s ID as shown below.\n   Resend the \u0026lsquo;search-brands\u0026rsquo; request to see your new brand listed in the response!\nCreate a new Product # Next let\u0026rsquo;s add a product. Run the \u0026lsquo;create-product\u0026rsquo; request at this point and you\u0026rsquo;ll see a failure message:\n{ \u0026quot;source\u0026quot;: \u0026quot;DN.WebApi.Application\u0026quot;, \u0026quot;exception\u0026quot;: \u0026quot;brand.notfound [en-US]\u0026quot;, \u0026quot;errorCode\u0026quot;: 404, \u0026quot;succeeded\u0026quot;: false }  What went wrong?? Click the \u0026lsquo;Body\u0026rsquo; tab and look at the value for the brandId. That field needs to match the ID value of the Brands table. When I created the Postman collection I had to use the values that existed while I was building the project from my workstation. If you revisit the \u0026lsquo;search-brands\u0026rsquo; request and look at the results you\u0026rsquo;ll see a value for \u0026lsquo;id\u0026rsquo;. Copy that value - return to the `create-product' request - replace the id value with what you\u0026rsquo;d copied and re-send the command. It should report success now.\n"}).add({id:10,href:"/dotnet-webapi-boilerplate/general/cli-commands/",title:"CLI Commands",description:"Here are some important CLI Commands that are to be used along with fullstackhero.",content:"Docker # Build # This command is to be executed from the root folder of the project.\ndocker build -t iammukeshm/dotnet-webapi:0.0.3-rc -t iammukeshm/dotnet-webapi:latest .  Push to DockerHub # This command is to be executed from the root folder of the project.\ndocker push iammukeshm/dotnet-webapi  Migrations # This command is to be executed from the Host Directory of the project.\ndotnet ef migrations add \u0026lt;CommitMessage\u0026gt; --project .././Migrators/Migrators.\u0026lt;Provider\u0026gt;/ --context ApplicationDbContext -o Migrations/Application  CommitMessage : Enter a commit message here. Provider : Enter the available DB Provider name. MSSQL , MySQL , PostgreSQL , Oracle\nWhile adding migrations for a particular provider, ensure that you have configured a valid connection string to the provider\u0026rsquo;s database at both src/Host/Configurations/database.json and src/Host/Configurations/hangfire.json.\nNuGet # Generates a NuGet Package of the entire solution. NuGet Configuration is available in the *.nuspec file at the root of the project directory. This command is to be executed from the Root Directory of the project.\nnuget pack -NoDefaultExcludes  "}).add({id:11,href:"/dotnet-webapi-boilerplate/general/project-structure/",title:"Project Structure",description:"Here is how the .NET WebApi Boilerplate is structured.",content:"fullstackhero\u0026rsquo;s .NET WebApi Boilerplate is based on Clean Architecture. In other words, Onion / Hexagonal Architecture. Read about the advantages and principles of Onion Architecture here â†’\nGeneral Structure # This means that the entire solution is built in such a way that it can be scaled, maintained easily by teams of developers. This WebAPI Solution Primarily consists of the following .csproj files.\nâ”œâ”€â”€ src â”‚ â”œâ”€â”€ Host | | â””â”€â”€ Host.csproj â”‚ â”œâ”€â”€ Core â”‚ | â”œâ”€â”€ Application.csproj â”‚ | â”œâ”€â”€ Shared.csproj â”‚ | â””â”€â”€ Domain.csproj | â”œâ”€â”€ Infrastructure | | â””â”€â”€ Infrastructure.csproj | â”œâ”€â”€ Migrators â”‚ | â”œâ”€â”€ Migrators.MSSQL.csproj â”‚ | â”œâ”€â”€ Migrators.MySQL.csproj â”‚ | â”œâ”€â”€ Migrators.PostgreSQL.csproj â”‚ | â””â”€â”€ Migrators.Oracle.csproj  The idea is to build a very loosely coupled architecture following best practices and packages. Let\u0026rsquo;s see in brief what responsibilities each of these projects handle.\nHost # Contains the API Controllers and Startup Logic including ASP.NET Core Container setup. This is the entry point of the application. Also, other static files like the logs, localization jsons, images, email templates and most importantly the configuration files live under this project.\nWith the release of 0.0.5-rc, the appSettings.json is further split into variable sub-setting like database.json, security.json and so on for better modularity and organization. You can find these new JSONs under the Configurations folder of the Host project.\nâ”œâ”€â”€ Host | â”œâ”€â”€ Configurations | â”œâ”€â”€ Controllers | â”œâ”€â”€ Email Templates | â”œâ”€â”€ Extensions | â”œâ”€â”€ Files â”‚ | â”œâ”€â”€ Images â”‚ | â””â”€â”€ Documents | â”œâ”€â”€ Localization | â”œâ”€â”€ Logs | â””â”€â”€ appsettings.json  Note that the Host project depends on\n Application Infrastructure Migration Projects  Application # This is one of the projects in the Core Folder apart from the Domain Project. Here you get to see Abstract Classes and Interfaces that are inherited and implemented in the Infrastructure Project. This refers to Dependency Inversion.\nâ”œâ”€â”€ Core | â”œâ”€â”€ Application | | â”œâ”€â”€ Auditing | | â”œâ”€â”€ Catalog | | â”œâ”€â”€ Common | | â”œâ”€â”€ Dashboard | | â”œâ”€â”€ Identity | | â””â”€â”€ Multitenancy  The folders and split at the top level Feature-wise. Meaning, it now makes it easier for developers to understand the folder structure. Each of the feature folders like Catalog will have all the files related to it\u0026rsquo;s scope including validators, dtos, interfaces and so on.\nThus everything related to a feature will be found directly under that Feature folder.\nIn cases where there are less number of classes / interfaces associated with a feature, all of these classes are put directly under the root of the feature folder. Only when the complexity of the feature increases, it is recommended to separate the classes by their type.\nNote that the Application project depends only on the Core projects which are Shared and Domain.\nDomain # Note that the Domain project does not depend on any other project other than the Shared project.\nAs per Clean Architecture principles, the Core of this Solution i.e, Application and Domain projects do not depend on any other projects. This helps achieve Dependency Inversion (The \u0026lsquo;D\u0026rsquo; Principle of \u0026lsquo;SOLID\u0026rsquo;).\n"}).add({id:12,href:"/dotnet-webapi-boilerplate/general/changelogs/",title:"Changelogs",description:"Track fullstackhero's Web API Changelogs.",content:"0.0.1-rc #  Initial release  0.0.2-rc #  Migration Refresh Security Patches Image Upload Fix Option to Disable Swagger Cleaner Code Activate / Deactivate Tenants Upgrade Tenant Subscription Advanced Search  0.0.3-rc #  Security Patches  0.0.4-rc #  Bug fix in Repository / Update method. Endpoint changes for Update / Delete Methods. (Postman Collection Updated) Fixed bug in Request Logging Middleware. Disabled Request Logger by default to save log space. Adds default Role (Basic) to any new registered user. Basic User has default View / Search Permissions Code Cleanups Templated Emails for User Registrations  0.0.5-rc #  Fixed Password Reset / Forgot Fixed Omnisharp Warnings / Code Cleanup Fixed Repository Method Log Hangfire to Serilog - Thanks frankyjquintero Extras Hangfire extensions - Thanks frankyjquintero Hangfire implementation examples - Thanks frankyjquintero Separate JSON files for each Settings - Thanks unchase Added Events and Handlers via MediatR - Thanks frankyjquintero Moved to Tenancy Middleware - Thanks frankyjquintero \u0026amp; fretje Solution Cleanup - rulesets \u0026amp; analyzer - Thanks fretje Added More Functions for RepositoryAsync - Thanks ghaithprosoft Entity Database Seeding Simplified File-Scoped namespaces and implicit usings Better Folder Structure / Modular  0.0.6-rc Current # Released on 2022-02-26\nRelease Tag - https://github.com/fullstackhero/dotnet-webapi-boilerplate/tree/0.0.6-rc\n AD Authentication Support Oracle DB Provider for EFCore support Code Refactors Added ElasticSearch + Kibana for Logging Added Docker Compose for ElasticSearch + Kibana Container Integrated Finbucke Multitenant packages Solution Restructure Added Scripts for Generating Migrations Introduced CQRS Pattern with MediatR Better Configuration Files Added .rest file for API Testing Updated Postman Collection Code Cleanup Updated all Packages Serilog Startup fix Export to Excel Support Specification Pattern using Ardalis packages OpenAPI Client Generation  "}).add({id:13,href:"/dotnet-webapi-boilerplate/fundamentals/configurations/",title:"Configurations",description:"Understanding Configurations in fullstackhero's Web API.",content:"Within the Host boot project there is a folder called \u0026ldquo;Configurations\u0026rdquo;. where there are all the configuration files, one for each area.\nGeneral Structure # â”œâ”€â”€ Host.csproj â”‚ â”œâ”€â”€ Configurations â”‚ | â”œâ”€â”€ cache.json â”‚ | â”œâ”€â”€ cors.json â”‚ | â”œâ”€â”€ database.json â”‚ | â”œâ”€â”€ hangfire.json â”‚ | â”œâ”€â”€ logger.json â”‚ | â”œâ”€â”€ mail.json â”‚ | â”œâ”€â”€ middleware.json â”‚ | â”œâ”€â”€ openapi.json â”‚ | â”œâ”€â”€ security.json â”‚ | â”œâ”€â”€ securityheaders.json â”‚ | â””â”€â”€ signalr.json | â”œâ”€â”€ appsettings.json |   The classic appsettings.json configuration file is still available to manage custom parameters.\n The Startup class inside the folder is responsible for loading all the configuration files described above.\n"}).add({id:14,href:"/dotnet-webapi-boilerplate/fundamentals/exception-handling/",title:"Exception Handling",description:"Understanding Exception Handling in fullstackhero's Web API.",content:"Documentation Coming Soon!\n"}).add({id:15,href:"/dotnet-webapi-boilerplate/fundamentals/localization/",title:"Localization",description:"Understanding Localization in fullstackhero's Web API.",content:"Documentation Coming Soon!\n"}).add({id:16,href:"/dotnet-webapi-boilerplate/fundamentals/application-startup/",title:"Application Startup",description:"Understanding application-startup in fullstackhero's Web API.",content:"Documentation Coming Soon!\n"}).add({id:17,href:"/dotnet-webapi-boilerplate/fundamentals/caching/",title:"Caching",description:"Understanding Caching in fullstackhero's Web API.",content:"Documentation Coming Soon!\n"}).add({id:18,href:"/dotnet-webapi-boilerplate/fundamentals/cors/",title:"CORS",description:"Understanding CORS in fullstackhero's Web API.",content:"CORS is an mechanism that allows a server to indicate any origins (domain, scheme, or port) other than its own.\nFullStackHero Web API has support for providing to several clients, all of the configurations related this feature can be found under src/Host/Configurations/cors.json.\nWe present two scenarios that demonstrate how Cross-Origin requests by clients can be served:\n{ \u0026quot;CorsSettings\u0026quot;: { \u0026quot;Angular\u0026quot;: \u0026quot;http://localhost:4200\u0026quot;, \u0026quot;Blazor\u0026quot;: \u0026quot;https://localhost:5002;https://www.mydomain.my\u0026quot; } }  "}).add({id:19,href:"/dotnet-webapi-boilerplate/fundamentals/hangfire/",title:"Hangfire",description:"Understanding Hangfire in fullstackhero's Web API.",content:"Documentation Coming Soon!\n"}).add({id:20,href:"/dotnet-webapi-boilerplate/fundamentals/logging/",title:"Logging",description:"Understanding Logging in fullstackhero's Web API.",content:"FullStackHero Web API has out of the box support for logging to several destinations. Thanks to the usage of Serilog! All of the configurations related to Logging can be found under src/Host/Configurations/logger.json.\nConsole # Console Logging is enabled by Default. This is done directly in the C# code and not in the JSON Configurations. You can find the code snippet at the Host\u0026rsquo;s Program.cs. Package used - Serilog.Sinks.Console\nbuilder.Host.UseSerilog((_, config) =\u0026gt; { config.WriteTo.Console() .ReadFrom.Configuration(builder.Configuration); });  Here is how the logs show up on Console via Serilog.\n   File # Structured logging is the best part of using Serilog! It is possible to use JSON formatters to evenly log messages and warning to files in the local directory. Package used - Serilog.Sinks.File\n\u0026quot;Name\u0026quot;: \u0026quot;File\u0026quot;, \u0026quot;Args\u0026quot;: { \u0026quot;path\u0026quot;: \u0026quot;Logs/logs.json\u0026quot;, \u0026quot;formatter\u0026quot;: \u0026quot;Serilog.Formatting.Json.JsonFormatter, Serilog\u0026quot;, \u0026quot;rollingInterval\u0026quot;: \u0026quot;Day\u0026quot;, \u0026quot;restrictedToMinimumLevel\u0026quot;: \u0026quot;Information\u0026quot;, \u0026quot;retainedFileCountLimit\u0026quot;: 5 }  The above configurations ensures that the logs are structured and has a new filename every day. Since we do not want to use of a lot of memory to keep these logs, it\u0026rsquo;s configured to keep the logs of the last 5 days only. Feel free to modify this. Also this only logs the messages that has a level of Information or above.\n   SEQ # Having a dashboard to analyze the logs and warning are always good to have. SEQ is one option for that. It collects application logs, filters it as you need, along with several other integrations.\nPackage used - Serilog.Sinks.Seq\nMake sure you have SEQ installed and running on your machine / environment. SEQ is free for Individual use. Once setup, point to the SEQ Instance. It usually runs over the 5341 port.\n\u0026quot;Name\u0026quot;: \u0026quot;Seq\u0026quot;, \u0026quot;Args\u0026quot;: { \u0026quot;serverUrl\u0026quot;: \u0026quot;http://localhost:5341\u0026quot; }     Elastic Search # Now, the interesting part! Elastic Search with Kibana for Logging. You will need instances of Kibana and ElasticSearch running. To make things simpler, I have included a docker-compose deployments\\elk\\docker-compose.elk.yml which has references to both Kibana and ElasticSearch Images of version 7.16.0.\nEnsure that you have Docker installed on your machine along with the Docker Extensions for Visual Code (or your favorite IDE). From VS Code, you can simply right click \\deployments\\elk\\docker-compose.elk.yml and click on Docker-Up. This would spin up the Kibana and ES instances for you in no time.\n   By default,\n Kibana runs on port 5601 - http://localhost:5601 Elastic Search runs on port 9200 - http://localhost:9200  Package used - Serilog.Sinks.Elasticsearch\n\u0026quot;Name\u0026quot;: \u0026quot;Elasticsearch\u0026quot;, \u0026quot;Args\u0026quot;: { \u0026quot;nodeUris\u0026quot;: \u0026quot;http://localhost:9200;\u0026quot;, \u0026quot;indexFormat\u0026quot;: \u0026quot;DN.WebApi-logs-{0:yyyy.MM}\u0026quot;, \u0026quot;numberOfShards\u0026quot;: 2, \u0026quot;numberOfReplicas\u0026quot;: 1, \u0026quot;restrictedToMinimumLevel\u0026quot;: \u0026quot;Information\u0026quot; }  You can see that we are pointing to port 9200 from our configuration. This instructs Serilog to write the logs to ElasticSearch DB.\nTo view the logs on Dashboard, navigate to http://localhost:5601\nFirstly, navigate to Kibana Spaces - http://localhost:5601/app/management/kibana/spaces\nFrom the sidebar, select Index Patterns and create a new one.\nIn the Name field - put in dn.webapi-logs* or whatever you have set in your Serilog Configuration under indexFormat. Select the Timestamp field as @timestamp. That\u0026rsquo;s it.\nNow, go to http://localhost:5601/app/discover\n   "}).add({id:21,href:"/dotnet-webapi-boilerplate/fundamentals/mail-service/",title:"Mail Service",description:"Understanding Mail Service in fullstackhero's Web API.",content:"Documentation Coming Soon!\n"}).add({id:22,href:"/dotnet-webapi-boilerplate/fundamentals/middlewares/",title:"Middlewares",description:"Understanding Middlewares in fullstackhero's Web API.",content:"Documentation Coming Soon!\n"}).add({id:23,href:"/dotnet-webapi-boilerplate/fundamentals/multitenancy/",title:"Multitenancy",description:"Understanding Multitenancy in fullstackhero's Web API.",content:"Documentation Coming Soon!\n"}).add({id:24,href:"/dotnet-webapi-boilerplate/fundamentals/security/",title:"Security",description:"Understanding Security in fullstackhero's Web API.",content:"Documentation Coming Soon!\n"}).add({id:25,href:"/dotnet-webapi-boilerplate/fundamentals/signalr/",title:"SignalR",description:"Understanding SignalR in fullstackhero's Web API.",content:"Documentation Coming Soon!\n"}).add({id:26,href:"/dotnet-webapi-boilerplate/fundamentals/swagger/",title:"Swagger",description:"Understanding Swagger in fullstackhero's Web API.",content:"Documentation Coming Soon!\n"}).add({id:27,href:"/dotnet-webapi-boilerplate/tutorials/database-migrations/",title:"Adding Database Migrations for Entity Framework Core",description:"Adding Database Migrations for Entity Framework Core with fullstackhero's Web API",content:"So, you have already added new entities into the Domain project, modified an existing entity or want to recreate all the pre-generated migrations? Here is how to proceed.\nNote that currently, fullstackhero\u0026rsquo;s Web API supports the following major DB Providers,\n MSSQL MySQL PostgreSQL Oracle  Download links to setup the supported Database providers are mentioned here - https://fullstackhero.net/dotnet-webapi-boilerplate/general/development-environment/\nTo maintain scalability, the database migrations of each of these DB Providers are kept in separate class library projects namely\n Migrators/Migrators.MSSQL Migrators/Migrators.MySQL Migrators/Migrators.PostgreSQL Migrators/Migrators.Oracle  Out of the box, the default migrations are already generated and is made available for you. This means you would\u0026rsquo;nt even have to run a update-database to get started. The Application startup already handles it for you.\nAs of now, fullstackhero\u0026rsquo;s Web API consists of the following EF Core DB Context classes,\n ApplicationDbContext - This is where you would ideally reference your new entities. By default, Catalog entities are referenced here. TenantDbContext - Related to Finbuckle\u0026rsquo;s Multitenancy setup of Stores.  which are maintained as 2 different sub-folders under each of the Migrator projects named as Application and Tenant folders.\nTo start with generating the database migrations, open your terminal on to the Host Project.\nNote that steps are almost same for all the Database providers. But make sure that you got to have the respective connection string of the Database Provider in the database.json and hangfire.json to continue.\nMeaning, if you intend to create / update migrations for MySQL,\n You have to ensure that you have the MySQL Server up and running on your development machine. You have a valid connection string to the MySQL Server updated on both the database.json and hangfire.json configuration files. This also assumes that you have updated \u0026quot;DBProvider\u0026quot;: \u0026quot;mysql\u0026quot; too.  Below are some sample configurations for MySQL Provider. The above is applicable to all the other DB Provider.\ndatabase.json # { \u0026quot;DatabaseSettings\u0026quot;: { \u0026quot;ConnectionString\u0026quot;: \u0026quot;server=localhost;uid=root;pwd=root;database=defaultRootDb;Allow User Variables=True\u0026quot;, \u0026quot;DBProvider\u0026quot;: \u0026quot;mysql\u0026quot; } }  hangfire.json # ... \u0026quot;Storage\u0026quot;: { \u0026quot;StorageProvider\u0026quot;: \u0026quot;mysql\u0026quot;, \u0026quot;ConnectionString\u0026quot;: \u0026quot;server=localhost;uid=root;pwd=root;database=defaultRootDb;Allow User Variables=True\u0026quot;, ...  The Provider values for other supported DBs are as follows.\n MSSQL - mssql PostgreSQL - postgresql Oracle - oracle  Once your connection strings are all updated in the mentioned configuration files, open up the command terminal on the Host Project\u0026rsquo;s directory and run the following commands.\nAs mentioned earlier, since we have 2 Db Contexts defined in our application, we will have seperate commands for each of the available context classes.\nThe generic command to add migrations over the Application Db Context goes like this,\ndotnet ef migrations add \u0026lt;CommitMessage\u0026gt; --project .././Migrators/Migrators.\u0026lt;DBProvider\u0026gt;/ --context ApplicationDbContext -o Migrations/Application  where\n \u0026lt;CommitMessage\u0026gt; should be replaced by an appropriate name that describes the Migration \u0026lt;DBProvider\u0026gt; should be replaced by your selected Database Provider (MSSQL, MySQL, Oracle or PostgreSQL)  The generic command to add migrations over the Tenant Db Context goes like this,\ndotnet ef migrations add \u0026lt;CommitMessage\u0026gt; --project .././Migrators/Migrators.\u0026lt;DBProvider\u0026gt;/ --context TenantDbContext -o Migrations/Tenant  where\n \u0026lt;CommitMessage\u0026gt; should be replaced by an appropriate name that describes the Migration \u0026lt;DBProvider\u0026gt; should be replaced by your selected Database Provider (MSSQL, MySQL, Oracle or PostgreSQL)  Keeping that in mind, here is how you would add Migrations for MySQL.\n Ensure that you have updated the connection string and dbProvider properties of both hangfire.json and database.json configuration files. Open up the command terminal on the Host Project\u0026rsquo;s directory. To add migrations related to ApplicationDbContext, run  dotnet ef migrations add AddedMenuEntity --project .././Migrators/Migrators.MySQL/ --context ApplicationDbContext -o Migrations/Application\nTo add migrations related to TenantDbContext, run  dotnet ef migrations add ModifiedTenantTable --project .././Migrators/Migrators.MySQL/ --context TenantDbContext -o Migrations/Tenant\nThat\u0026rsquo;s almost it. Once the process is completed you would be able see new Migration cs files that represent your new additions / modifications at the table level added to the respective Migrator project.\nYou do not have to do anything extra to apply the migrations to your database. The application does it for you during the startup. Cheers!\n"}).add({id:28,href:"/dotnet-webapi-boilerplate/tutorials/crud-guide/",title:"Performing CRUD Operations",description:"Performing CRUD Operations with fullstackhero's Web API",content:"Documentation Coming Soon!\n"}).add({id:29,href:"/dotnet-webapi-boilerplate/tutorials/azure-ad-guide/",title:"Setting up Azure AD Authentication",description:"Setting up Azure AD Authentication with fullstackhero's Web API",content:"For the Azure AD integration to work with this template, you have to create 2 App Registrations under your Azure AD tenant with the right settings, and then fill out the AzureAd section in Configurations/security.json to hook those apps up. This guide will walk you through doing all that.\nCreate the FSHApi Application Registration #   Log into the azure portal and go to the Azure Active Directory blade. Make sure you are in the directory where you want your apps to be registered. You can switch directories by clicking on your account info in the top right corner.\n  Under Manage, click on App registrations, and click the New registration button on top:      Fill in FSHApi (or whichever name you want for this app) as Name. Under Supported account types select Accounts in any organizational directory - Multitenant and click on Register:      Expose the Api #   On the newly created App\u0026rsquo;s blade, under Manage, click on Expose an API, then click on Add a scope:      An Application ID URIq will automatically be filled out. Click on Save and continue:      On the next screen, fill in access_as_user as Scope name, select Admins and users as Who can consent? and fill out the display names and descriptions like in the screenshot below, then click on Add scope:      Add App roles #   Under Manage, click on App roles and click the Create app role button on top:      Fill in Administrators as Display name and Admin as value. Especially the value is important, as this has to match the name of the role in the FSH application itself. Click on Apply:      In the same way, create app roles for the other roles in your application (by default the only other role is the Basic role).\n  Assign App roles to specific users in AzureAD # You will have to assign those freshly created App roles to the AzureAd users to which you want to grant access to your application:\n  On the Azure Active Directory blade, under Manage click on Enterprise applications and select the FSHApi application:      Under Manage, click on Users and groups and click the Add user/group button on top:      On the next screen, you can select one or more users/groups, select an App role and click on the Assign button to assign the role the the specified users/groups.\n  Create the Client Application Registration #   Go back again to the Azure Active Directory blade and under Manage, click on App registrations, and click the New registration button on top again.\n  This time, fill out FSHClient as Name, choose again for Accounts in any organizational directory - Multitenant and under Redirect URI, select Single-page application (SPA) and fill out the url https://localhost:5001/swagger/oauth2-redirect.html. Click on Register:      Add permission for the Api #   On the newly created App\u0026rsquo;s blade, under Manage, click on API permissions and click the Add a permission button:      On the next view, under Select an API, click on My APIs and select FSHApi:      Then, under Select permissions, check the access_as_user permission and click on Add permissions:      Add Blazor Client application # This should be enough for testing from swagger. But you\u0026rsquo;ll probably will want to use the client application as well. There\u0026rsquo;s 2 options here. Or you can add the Redirect URI for the client application to the same App registration you just created (click on Authentication under Manage and then on Add URI), or you can create a whole new client app registration specifically for this client, just like described in the steps above, but with another Redirect URI. In any case, the Redirect URI for the blazor app you will want to use is https://localhost:5002/authentication/login-callback.\nUpdate the AzureAd settings on the Web Api project # Now that\u0026rsquo;s all set up, the only thing left is updating the configuration to use AzureAd. On the Web API project, under src\\Host\\Configurations, open security.json and fill out the required settings:\n Provider: set to AzureAd Instance: set to https://login.microsoftonline.com/ Domain: you can find your domain in the Azure Active Directory blade on the Overview page under Primary domain. TenantId: set to organizations ClientId: set to the Application (client) ID of the FSHApi App registration (you can find this on the Overview page of the App registration in Azure) Scopes: set to access_as_user RootIssuer: set to https://sts.windows.net/\u0026lt;Your Tenant ID\u0026gt;/ (your Tenant ID is also on the Overview page of the Azure Active Directory blade)  Then for swagger to work you need the following settings under the Swagger node in security.json:\n AuthorizationUrl: set to https://login.microsoftonline.com/organizations/oauth2/v2.0/authorize TokenUrl: set to https://login.microsoftonline.com/organizations/oauth2/v2.0/token ApiScope: set to the full name of the api scope we created in the FSHApi App registration above (api://\u0026lt;ClientId of the FSHApi App registration\u0026gt;/access_as_user) OpenIdClientId: set to the Application (client) ID of the FSHClient App registration (or the one you specifically created for swagger).  Update the AzureAd settings on the Blazor Client project # Then for the blazor client to work, you need the following settings over there in the wwwroot/appsettings.json file:\n AuthProvider: set to AzureAd Authority: set to https://login.microsoftonline.com/organizations ClientId: set to the Application (client) ID of the FSHClient App registration (or the one you specifically created for the blazor client). ValidateAuthority: set to true ApiScope: set to the full name of the api scope we created in the FSHApi App registration (api://\u0026lt;ClientId of the FSHApi App registration\u0026gt;/access_as_user) same as before with the swagger client.  Configuration for Postman # TODO - Coming soon\nTest it out #   Start the Web API project and browse to https://localhost:5001/swagger when you click on the Authorize button on the top right, you should be redirected to the Microsoft login site. Log in with a user to which you granted app roles and you should be redirected back to swagger with the padlock closed. When you now issue an api call, the Authorization header should be sent with the bearer token received from AzureAd.\n  Start the Blazor Client project and browse to https://localhost:5002/. You should be immediately redirected to the Microsoft login site. And after logging in, you should be redirected back to the homepage of the blazor client.\n  AzureAd and multitenancy # About the RootIssuersetting in security.json. This should be set to the issuer of the root tenant in AzureAd. When someone is logging in from that AzureAD tenant, the local root tenant will automatically be selected.\nFor the other tenants there\u0026rsquo;s an \u0026ldquo;issuer\u0026rdquo; field in the tenants table to map those. There\u0026rsquo;s still a part which has to be implemented for mutltiple tenants from AzureAd though, as there needs to be some kind of \u0026ldquo;onboarding\u0026rdquo; experience inside AzureAD when a new tenant needs access to you application. See https://docs.microsoft.com/en-us/azure/architecture/multitenant-identity/signup for more info about this.\nAzureAd users/roles vs. local users/roles # In any case, with AzureAd, when a user logs in and there doesn\u0026rsquo;t exist a local user yet in the local tenant for that AzureAd user/tenant, one gets created automatically. It will also immediately have the same roles assigned like the ones in AzureAd. When an already existing user logs in and there are roles in AzureAd for that user which are not yet assigned to the local user, they will automatically be assigned. Currently there will never be any roles removed from a user. So removing the role assignment from AzureAd will not automatically remove it from the local user when he logs in. This to allow for people to use the role/permission management inside the app without having to do it in Azure.\n"}).add({id:30,href:"/dotnet-webapi-boilerplate/tutorials/deploying-to-iis/",title:"Deploying to IIS",description:"Deploying fullstackhero's Web API to IIS",content:"Documentation Coming Soon!\n"}).add({id:31,href:"/blog/say-hello-to-doks/",title:"Say hello to Doks ðŸ‘‹",description:"Introducing Doks, a Hugo theme helping you build modern documentation websites that are secure, fast, and SEO-ready â€” by default.",content:""}).add({id:32,href:"/blazor-webassembly-boilerplate/ui-overview/fundamentals/",title:"Fundamentals",description:"Exploring fullstackhero's Blazor WebAssembly Boilerplate.",content:"Here are some of the general components, features and pages that you get to see in fullstackhero\u0026rsquo;s Blazor WebAssembly Boilerplate.\nLoading Screen # The following is the dedault loading screen of the template.\nYou can tweak around the appearance by modifying \\src\\Client\\wwwroot\\index.html.\n   Basic Layout # By default, the boilerplate sports an ADMIN Dashboard template that is mostly used for Management of Entities.\nNavigation Bar #    Side Menu #    Body #    Theme Manager # fullstackhero\u0026rsquo;s Blazor WebAssembly Boilerplate comes with a built-in theme manager that helps you customize various UI aspects right from primary colors to the radius of the containers with ease. You can view the Theme Manager component by clicking on the Paint Icon that you would see on every page of the boilerplate.\nNote that each of the configuration changes you make get stored to your browser\u0026rsquo;s localstorage.\n   Dark Mode # Easily Switch to Dark / Light Mode with a toggle that you find on the theme manager!\n   Colors # Here you get to set the Primary and Secondary colors used by the Blazor Application and personalize the already rich UI Boilerplate.\n      Not finding the color that you need? You can easily add new colors to this pallete by changing some code!\nIn the below screenshot you can find the default 12 colors defined in code.\n   Border Radius # The Adjustable Slider helps you manipulate the Borders of the UI components.\n   Table Customization #    "}).add({id:33,href:"/blazor-webassembly-boilerplate/ui-overview/authentication/",title:"Authentication",description:"Auth Related Pages / Components in fullstackhero's Blazor WebAssembly Boilerplate.",content:"Login # Here is what you would be welcomed with, the login page! You can auto-fill the default username / password \u0026amp; tenant by clicking on the Fill Administrator Credentials button.\nAnyways, here are the default login details for your reference.\n email - admin@root.com password - 123Pa$$word! tenant - root   Make sure that you use valid tenant values! By default, only root tenant is created for you.      Forgot Password # In case, you happen to forget your password, the application has the functionailty to reset the password for you.\n   "}).add({id:34,href:"/blazor-webassembly-boilerplate/ui-overview/home/",title:"Home",description:"Home Page in fullstackhero's Blazor WebAssembly Boilerplate.",content:"   "}).add({id:35,href:"/blazor-webassembly-boilerplate/ui-overview/dashboard/",title:"Dashboard",description:"Dashboard in fullstackhero's Blazor WebAssembly Boilerplate.",content:""}).add({id:36,href:"/blazor-webassembly-boilerplate/ui-overview/account/",title:"Account",description:"Account Page in fullstackhero's Blazor WebAssembly Boilerplate.",content:""}).add({id:37,href:"/blazor-webassembly-boilerplate/ui-overview/logs/",title:"Logs",description:"Logs Page in fullstackhero's Blazor WebAssembly Boilerplate.",content:""}).add({id:38,href:"/blazor-webassembly-boilerplate/ui-overview/catalog-management/",title:"Catalog Management",description:"Catalog Management Pages in fullstackhero's Blazor WebAssembly Boilerplate.",content:""}).add({id:39,href:"/blazor-webassembly-boilerplate/ui-overview/user-management/",title:"User Management",description:"User Management Pages in fullstackhero's Blazor WebAssembly Boilerplate.",content:""}).add({id:40,href:"/blazor-webassembly-boilerplate/ui-overview/role-management/",title:"Role Management",description:"Role Management Pages in fullstackhero's Blazor WebAssembly Boilerplate.",content:""}).add({id:41,href:"/blazor-webassembly-boilerplate/ui-overview/tenant-management/",title:"Tenant Management",description:"Tenant Management Pages in fullstackhero's Blazor WebAssembly Boilerplate.",content:""}).add({id:42,href:"/blazor-webassembly-boilerplate/ui-overview/dialogs/",title:"Dialogs",description:"Exploring Dialogs fullstackhero's Blazor WebAssembly Boilerplate.",content:"LogOut # Confirmation # "}),search.addEventListener('input',b,!0);function b(){var b,e;const d=5;b=this.value,e=a.search(b,{limit:d,enrich:!0});const c=new Map;for(const a of e.flatMap(a=>a.result)){if(c.has(a.doc.href))continue;c.set(a.doc.href,a.doc)}if(suggestions.innerHTML="",suggestions.classList.remove('d-none'),c.size===0&&b){const a=document.createElement('div');a.innerHTML=`No results for "<strong>${b}</strong>"`,a.classList.add("suggestion__no-results"),suggestions.appendChild(a);return}for(const[h,g]of c){const b=document.createElement('div');suggestions.appendChild(b);const a=document.createElement('a');a.href=h,b.appendChild(a);const e=document.createElement('span');e.textContent=g.title,e.classList.add("suggestion__title"),a.appendChild(e);const f=document.createElement('span');if(f.textContent=g.description,f.classList.add("suggestion__description"),a.appendChild(f),suggestions.appendChild(b),suggestions.childElementCount==d)break}}})()